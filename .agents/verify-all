#!/bin/bash
#
# Unified verification script - Single source of truth for all checks
#
# Runs all code quality checks (formatting, linting, type-checking, tests)
# with intelligent caching to avoid duplicate checks.
#
# Cache strategy:
# - Files tracked: src/, tests/, pyproject.toml, poetry.lock, .git/index
# - Cache key: SHA256 hash of all tracked files
# - Cache TTL: Until any tracked file changes
# - Result includes: exit_code, timestamp, duration, check details
#
# Used by:
# - .git/hooks/pre-commit (must pass, blocks commit)
# - .git/hooks/pre-push (informational, blocks if fail)
# - .agents/hooks/post-task (non-blocking, informs developer)
#
# Exit codes:
# - 0: All checks passed
# - 1: Some checks failed
# - 2: Cache miss (checks ran fresh)
#

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Colors are optional (disable if NO_COLOR is set)
if [ -n "$NO_COLOR" ]; then
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Determine script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CACHE_DIR="$PROJECT_ROOT/.devloop/check-cache"
CACHE_HASH_FILE="$CACHE_DIR/file-hash.txt"
CACHE_RESULT_FILE="$CACHE_DIR/result.json"

# Change to project root
cd "$PROJECT_ROOT"

# Early exit: Only .beads/ files staged? Skip all checks.
STAGED_FILES=$(git diff --cached --name-only 2>/dev/null | grep -v '\.beads/')
if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}[Verify-All] ℹ️  Only .beads/ files staged, skipping checks${NC}"
    exit 0
fi

# ============================================================================
# Helper: Compute hash of tracked files
# ============================================================================
compute_file_hash() {
    local hash_input=""
    
    # Hash src/ and tests/ directories
    if [ -d "src" ]; then
        hash_input="${hash_input}$(find src -type f -name '*.py' -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)"
    fi
    if [ -d "tests" ]; then
        hash_input="${hash_input}$(find tests -type f -name '*.py' -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)"
    fi
    
    # Hash pyproject.toml and poetry.lock if they exist
    if [ -f "pyproject.toml" ]; then
        hash_input="${hash_input}$(sha256sum pyproject.toml | cut -d' ' -f1)"
    fi
    if [ -f "poetry.lock" ]; then
        hash_input="${hash_input}$(sha256sum poetry.lock | cut -d' ' -f1)"
    fi
    
    # Hash .git/index (tracks staged changes)
    if [ -f ".git/index" ]; then
        hash_input="${hash_input}$(sha256sum .git/index | cut -d' ' -f1)"
    fi
    
    # Final combined hash
    echo "$hash_input" | sha256sum | cut -d' ' -f1
}

# ============================================================================
# Helper: Run all checks (Black, Ruff, mypy, pytest) in parallel
# ============================================================================
run_all_checks() {
    local start_time=$(date +%s)
    local temp_dir="/tmp/verify-all-$$"
    mkdir -p "$temp_dir"
    
    echo -e "${BLUE}[Verify-All] Running code quality checks (parallel)...${NC}"
    echo ""
    
    local exit_code=0
    
    # Run Black (formatting check) - 20s typical
    echo -e "${YELLOW}[Verify-All] Checking code formatting (Black)...${NC}"
    if ! poetry run black --check src/ tests/ >"$temp_dir/black.txt" 2>&1; then
        echo -e "${RED}[Verify-All] ❌ Black formatting failed:${NC}"
        cat "$temp_dir/black.txt"
        echo -e "${YELLOW}Fix: poetry run black src/ tests/${NC}"
        exit_code=1
    else
        echo -e "${GREEN}[Verify-All] ✅ Black formatting passed${NC}"
    fi
    
    # Run Ruff (linting) - 30s typical
    echo -e "${YELLOW}[Verify-All] Running linter (Ruff)...${NC}"
    if ! poetry run ruff check src/ >"$temp_dir/ruff.txt" 2>&1; then
        echo -e "${RED}[Verify-All] ❌ Ruff linting failed:${NC}"
        cat "$temp_dir/ruff.txt"
        echo -e "${YELLOW}Fix: poetry run ruff check src/ --fix${NC}"
        exit_code=1
    else
        echo -e "${GREEN}[Verify-All] ✅ Ruff linting passed${NC}"
    fi
    
    # Run mypy (type checking) - 50s typical
    echo -e "${YELLOW}[Verify-All] Type checking (mypy)...${NC}"
    cd src
    if ! poetry run mypy devloop/core/ devloop/agents/ >"$temp_dir/mypy.txt" 2>&1; then
        echo -e "${RED}[Verify-All] ❌ Type check failed:${NC}"
        cat "$temp_dir/mypy.txt"
        cd ..
        exit_code=1
    else
        echo -e "${GREEN}[Verify-All] ✅ Type checks passed${NC}"
        cd ..
    fi
    
    # Run pytest (tests) - 90s typical
    echo -e "${YELLOW}[Verify-All] Running tests (pytest)...${NC}"
    if ! poetry run pytest tests/ -q >"$temp_dir/pytest.txt" 2>&1; then
        echo -e "${RED}[Verify-All] ❌ Tests failed:${NC}"
        tail -50 "$temp_dir/pytest.txt"
        exit_code=1
    else
        echo -e "${GREEN}[Verify-All] ✅ All tests passed${NC}"
    fi
    
    # Poetry lock sync check (metadata)
    if [ -f "poetry.lock" ] && [ -f "pyproject.toml" ]; then
        if git diff --cached --name-only 2>/dev/null | grep -q "pyproject.toml"; then
            if ! git diff --cached --name-only 2>/dev/null | grep -q "poetry.lock"; then
                echo -e "${YELLOW}[Verify-All] Warning: pyproject.toml changed but poetry.lock not updated${NC}"
                exit_code=1
            fi
        fi
    fi
    
    # Version consistency check (metadata)
    if [ -f "pyproject.toml" ] && [ -f "src/devloop/__init__.py" ]; then
        PYPROJECT_VERSION=$(grep '^version = ' pyproject.toml 2>/dev/null | sed 's/version = "\(.*\)"/\1/')
        INIT_VERSION=$(grep '^__version__ = ' src/devloop/__init__.py 2>/dev/null | sed 's/__version__ = "\(.*\)"/\1/')
        if [ -n "$PYPROJECT_VERSION" ] && [ -n "$INIT_VERSION" ] && [ "$PYPROJECT_VERSION" != "$INIT_VERSION" ]; then
            echo -e "${YELLOW}[Verify-All] Warning: Version mismatch (pyproject.toml vs __init__.py)${NC}"
            echo -e "${YELLOW}  pyproject.toml:           $PYPROJECT_VERSION${NC}"
            echo -e "${YELLOW}  src/devloop/__init__.py:  $INIT_VERSION${NC}"
            exit_code=1
        fi
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Save result to cache
    mkdir -p "$CACHE_DIR"
    cat > "$CACHE_RESULT_FILE" <<EOF
{
  "exit_code": $exit_code,
  "timestamp": $(date +%s),
  "duration": $duration,
  "date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "checks": {
    "black": "$([ $exit_code -eq 0 ] && echo 'pass' || echo 'fail')",
    "ruff": "$([ $exit_code -eq 0 ] && echo 'pass' || echo 'fail')",
    "mypy": "$([ $exit_code -eq 0 ] && echo 'pass' || echo 'fail')",
    "pytest": "$([ $exit_code -eq 0 ] && echo 'pass' || echo 'fail')"
  }
}
EOF
    
    # Cleanup temp directory
    rm -rf "$temp_dir"
    
    echo ""
    echo -e "${BLUE}[Verify-All] Completed in ${duration}s${NC}"
    
    return $exit_code
}

# ============================================================================
# Cache validation logic
# ============================================================================
echo -e "${BLUE}[Verify-All] Checking cache status...${NC}"

current_hash=$(compute_file_hash)

if [ -f "$CACHE_HASH_FILE" ] && [ -f "$CACHE_RESULT_FILE" ]; then
    cached_hash=$(cat "$CACHE_HASH_FILE")
    
    if [ "$current_hash" = "$cached_hash" ]; then
        # Cache hit! Use cached result
        cached_exit_code=$(grep -o '"exit_code": [0-9]*' "$CACHE_RESULT_FILE" | grep -o '[0-9]*')
        cached_timestamp=$(grep -o '"date": "[^"]*"' "$CACHE_RESULT_FILE" | cut -d'"' -f4)
        
        echo -e "${GREEN}[Verify-All] ✅ Cache hit (valid for all file changes)${NC}"
        echo -e "${YELLOW}[Verify-All] Last checks ran at: $cached_timestamp${NC}"
        echo -e "${YELLOW}[Verify-All] Using cached result...${NC}"
        echo ""
        
        if [ "$cached_exit_code" -eq 0 ]; then
            echo -e "${GREEN}[Verify-All] ✅ All checks passed (cached result)${NC}"
            exit 0
        else
            echo -e "${RED}[Verify-All] ❌ Previous checks failed (cached result)${NC}"
            exit 1
        fi
    fi
fi

# ============================================================================
# Cache miss: Run fresh checks
# ============================================================================
echo -e "${YELLOW}[Verify-All] Cache miss (files changed), running fresh checks...${NC}"
echo ""

if run_all_checks; then
    # Save hash for next time
    mkdir -p "$CACHE_DIR"
    echo "$current_hash" > "$CACHE_HASH_FILE"
    
    echo -e "${GREEN}[Verify-All] ✅ All checks passed${NC}"
    exit 0
else
    # Don't cache failed results - let them retry immediately
    exit 1
fi
